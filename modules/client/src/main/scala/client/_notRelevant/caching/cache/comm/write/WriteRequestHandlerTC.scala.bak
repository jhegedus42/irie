package client._notRelevant.caching.cache.syncedState.comm.write

import WriteRequestHandlerStates.WriteHandlerState
import client._notRelevant.caching.cache.syncedState.comm.AJAXCalls
import client._notRelevant.caching.cache.syncedState.comm.write.WriteAjaxReturnedStream.Payload
import app.shared.syncedState.comm.postRequests.write.{CreateEntityReq, UpdateReq}
import app.shared.syncedState.comm.{PostRequest, WriteRequest}
import app.shared.values.{Image, Note, User}
import io.circe.{Decoder, Encoder}
import client.sodium.core.StreamSink
import client.sodium.core.Stream

import scala.reflect.ClassTag

object WriteAjaxReturnedStream {

  case class Payload[Req <: PostRequest[WriteRequest]](
    par: Req#ParT,
    res: Req#ResT)

}

trait WriteRequestHandlerTC[Req <: PostRequest[WriteRequest]] {

  def executeRequest(
    par: Req#ParT
  )(
    implicit
    decoder: Decoder[Req#ResT],
    encoder: Encoder[Req#ParT],
    ct:      ClassTag[Req],
    ct2:     ClassTag[Req#PayLoadT]
  ): Stream[WriteHandlerState[Req]]

  val stream: StreamSink[Req#ParT] = new StreamSink[Req#ParT]()
  val streamState: StreamSink[WriteHandlerState[Req]] = new StreamSink[WriteHandlerState[Req]]()

}

object WriteRequestHandlerTC {

  implicit val userUpdater =
    new WriteRequestHandlerTCImpl[UpdateReq[User]] {}

  implicit val noteUpdater =
    new WriteRequestHandlerTCImpl[UpdateReq[Note]] {}

  implicit val createUser =
    new WriteRequestHandlerTCImpl[CreateEntityReq[User]] {}

  implicit val createNote =
    new WriteRequestHandlerTCImpl[CreateEntityReq[Note]] {}

  implicit val createImage =
    new WriteRequestHandlerTCImpl[CreateEntityReq[Image]] {}


}
